// Do not edit: This code was generated by flatdata's generator.
pub mod test {

    pub mod schema {
        pub mod structs {
            pub const A: &str = r#"namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
}
}

"#;
            pub const B: &str = r#"namespace test {
struct B
{
    value : u32 : 16;
}
}

"#;
            pub const R: &str = r#"namespace test {
struct R
{
    @range( x )
    first_x : u32 : 16;
}
}

"#;
        }
        pub mod x {
            pub const X: &str = r#"namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
}
}

namespace test {
struct B
{
    value : u32 : 16;
}
}

namespace test {
archive X
{
    data : vector< .test.A >;
    heterogeneous_data : multivector< 32, .test.A, .test.B >;
}
}

"#;
            pub mod resources {
                pub const DATA: &str = r#"namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
}
}

namespace test {
archive X
{
    data : vector< .test.A >;
}
}

"#;
                pub const HETEROGENEOUS_DATA: &str = r#"namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
}
}

namespace test {
struct B
{
    value : u32 : 16;
}
}

namespace test {
archive X
{
    heterogeneous_data : multivector< 32, .test.A, .test.B >;
}
}

"#;
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct A {}

    #[derive(Clone, Copy)]
    pub struct ARef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> crate::Struct<'a> for A {
        const SCHEMA: &'static str = schema::structs::A;
        const SIZE_IN_BYTES: usize = 4;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = ARef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = AMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl crate::NoOverlap for A {}

    impl<'a> ARef<'a> {
        #[inline]
        pub fn x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn y(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 16, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for ARef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("A")
                .field("x", &self.x())
                .field("y", &self.y())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for ARef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.x() == other.x() && self.y() == other.y()
        }
    }

    impl<'a> crate::Ref for ARef<'a> {}

    pub struct AMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> AMut<'a> {
        #[inline]
        pub fn x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_x(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 4) };
            flatdata_write_bytes!(u32; value, buffer, 0, 16)
        }

        #[inline]
        pub fn y(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 16, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_y(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 4) };
            flatdata_write_bytes!(u32; value, buffer, 16, 16)
        }

        #[inline]
        pub fn fill_from(&mut self, other: &ARef) {
            self.set_x(other.x());
            self.set_y(other.y());
        }

        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }

        #[inline]
        pub fn as_mut_ptr(&self) -> *mut u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for AMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            ARef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> crate::RefMut for AMut<'a> {}

    #[derive(Clone, Debug)]
    pub struct B {}

    #[derive(Clone, Copy)]
    pub struct BRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> crate::Struct<'a> for B {
        const SCHEMA: &'static str = schema::structs::B;
        const SIZE_IN_BYTES: usize = 2;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = BRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = BMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl crate::NoOverlap for B {}

    impl<'a> BRef<'a> {
        #[inline]
        pub fn value(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for BRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("B").field("value", &self.value()).finish()
        }
    }

    impl<'a> std::cmp::PartialEq for BRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.value() == other.value()
        }
    }

    impl<'a> crate::Ref for BRef<'a> {}

    pub struct BMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> BMut<'a> {
        #[inline]
        pub fn value(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_value(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 2) };
            flatdata_write_bytes!(u32; value, buffer, 0, 16)
        }

        #[inline]
        pub fn fill_from(&mut self, other: &BRef) {
            self.set_value(other.value());
        }

        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }

        #[inline]
        pub fn as_mut_ptr(&self) -> *mut u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for BMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            BRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> crate::RefMut for BMut<'a> {}

    #[derive(Clone, Debug)]
    pub struct R {}

    #[derive(Clone, Copy)]
    pub struct RRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> crate::Struct<'a> for R {
        const SCHEMA: &'static str = schema::structs::R;
        const SIZE_IN_BYTES: usize = 2;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;

        type Item = RRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = RMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl<'a> RRef<'a> {
        #[inline]
        pub fn first_x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn x(&self) -> std::ops::Range<u32> {
            let start = flatdata_read_bytes!(u32, self.data, 0, 16);
            let end = flatdata_read_bytes!(u32, self.data, 0 + 2 * 8, 16);
            start..end
        }

        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for RRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("R")
                .field("first_x", &self.first_x())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for RRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.first_x() == other.first_x()
        }
    }

    impl<'a> crate::Ref for RRef<'a> {}

    pub struct RMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> RMut<'a> {
        #[inline]
        pub fn first_x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_first_x(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 2) };
            flatdata_write_bytes!(u32; value, buffer, 0, 16)
        }

        #[inline]
        pub fn fill_from(&mut self, other: &RRef) {
            self.set_first_x(other.first_x());
        }

        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }

        #[inline]
        pub fn as_mut_ptr(&self) -> *mut u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for RMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            RRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> crate::RefMut for RMut<'a> {}

    /// Builtin union type of .test.A, .test.B.
    #[derive(Clone, PartialEq)]
    pub enum HeterogeneousDataRef<'a> {
        A(<super::test::A as crate::Struct<'a>>::Item),
        B(<super::test::B as crate::Struct<'a>>::Item),
    }

    impl<'a> ::std::fmt::Debug for HeterogeneousDataRef<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                HeterogeneousDataRef::A(ref inner) => write!(f, "{:?}", inner),
                HeterogeneousDataRef::B(ref inner) => write!(f, "{:?}", inner),
            }
        }
    }

    impl<'a> crate::VariadicRef for HeterogeneousDataRef<'a> {
        #[inline]
        fn size_in_bytes(&self) -> usize {
            match *self {
                HeterogeneousDataRef::A(_) => <super::test::A as crate::Struct<'a>>::SIZE_IN_BYTES,
                HeterogeneousDataRef::B(_) => <super::test::B as crate::Struct<'a>>::SIZE_IN_BYTES,
            }
        }
    }

    pub struct HeterogeneousDataBuilder<'a> {
        data: &'a mut Vec<u8>,
    }

    impl<'a> HeterogeneousDataBuilder<'a> {
        #[inline]
        pub fn add_a<'b>(&'b mut self) -> <super::test::A as crate::Struct<'b>>::ItemMut {
            let old_len = self.data.len();
            let increment = 1 + <super::test::A as crate::Struct<'b>>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len - crate::PADDING_SIZE] = 0;
            <super::test::A as crate::Struct<'b>>::create_mut(
                &mut self.data[1 + old_len - crate::PADDING_SIZE..],
            )
        }
        #[inline]
        pub fn add_b<'b>(&'b mut self) -> <super::test::B as crate::Struct<'b>>::ItemMut {
            let old_len = self.data.len();
            let increment = 1 + <super::test::B as crate::Struct<'b>>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len - crate::PADDING_SIZE] = 1;
            <super::test::B as crate::Struct<'b>>::create_mut(
                &mut self.data[1 + old_len - crate::PADDING_SIZE..],
            )
        }
    }

    #[derive(Clone)]
    pub struct HeterogeneousData {}

    impl<'a> crate::VariadicStruct<'a> for HeterogeneousData {
        type Index = super::_builtin::multivector::IndexType32;

        type Item = HeterogeneousDataRef<'a>;

        #[inline]
        fn create(index: crate::TypeIndex, data: &'a [u8]) -> Self::Item {
            match index {
                0 => HeterogeneousDataRef::A(<super::test::A as crate::Struct<'a>>::create(data)),
                1 => HeterogeneousDataRef::B(<super::test::B as crate::Struct<'a>>::create(data)),
                _ => panic!(
                    "invalid type index {} for variadic type HeterogeneousDataRef",
                    index
                ),
            }
        }

        type ItemMut = HeterogeneousDataBuilder<'a>;

        #[inline]
        fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut {
            Self::ItemMut { data }
        }
    }

    #[derive(Clone)]
    pub struct X {
        _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
        data: crate::MemoryDescriptor,
        heterogeneous_data: (crate::MemoryDescriptor, crate::MemoryDescriptor),
    }

    impl X {
        fn read_resource(
            storage: &dyn crate::ResourceStorage,
            name: &str,
            schema: &str,
        ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError> {
            storage
                .read(name, schema)
                .map(|x| crate::MemoryDescriptor::new(&x))
        }

        fn signature_name(archive_name: &str) -> String {
            format!("{}.archive", archive_name)
        }

        #[inline]
        pub fn data(&self) -> crate::ArrayView<super::test::A> {
            crate::ArrayView::new(&unsafe { self.data.as_bytes() })
        }

        #[inline]
        pub fn heterogeneous_data(&self) -> crate::MultiArrayView<HeterogeneousData> {
            crate::MultiArrayView::new(
                crate::ArrayView::new(&unsafe { self.heterogeneous_data.0.as_bytes() }),
                &unsafe { self.heterogeneous_data.1.as_bytes() },
            )
        }
    }

    impl ::std::fmt::Debug for X {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            f.debug_struct("X")
                .field("data", &self.data())
                .field("heterogeneous_data", &self.heterogeneous_data())
                .finish()
        }
    }

    impl crate::Archive for X {
        const NAME: &'static str = "X";
        const SCHEMA: &'static str = schema::x::X;

        fn open(
            storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
        ) -> ::std::result::Result<Self, crate::ResourceStorageError> {
            storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

            let data = Self::read_resource(&*storage, "data", schema::x::resources::DATA)?;
            let heterogeneous_data = {
                let index_schema = &format!("index({})", schema::x::resources::HETEROGENEOUS_DATA);
                let index =
                    Self::read_resource(&*storage, "heterogeneous_data_index", &index_schema)?;
                let data = Self::read_resource(
                    &*storage,
                    "heterogeneous_data",
                    schema::x::resources::HETEROGENEOUS_DATA,
                )?;
                (index, data)
            };

            Ok(Self {
                _storage: storage,
                data,
                heterogeneous_data,
            })
        }
    }

    #[derive(Clone, Debug)]
    pub struct XBuilder {
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    }

    impl XBuilder {
        #[inline]
        pub fn set_data(&self, vector: &crate::ArrayView<super::test::A>) -> ::std::io::Result<()> {
            self.storage
                .write("data", schema::x::resources::DATA, vector.as_ref())
        }

        #[inline]
        pub fn start_data(&self) -> ::std::io::Result<crate::ExternalVector<super::test::A>> {
            crate::create_external_vector(&*self.storage, "data", schema::x::resources::DATA)
        }

        #[inline]
        pub fn start_heterogeneous_data(
            &self,
        ) -> ::std::io::Result<crate::MultiVector<HeterogeneousData>> {
            crate::create_multi_vector(
                &*self.storage,
                "heterogeneous_data",
                schema::x::resources::HETEROGENEOUS_DATA,
            )
        }
    }

    impl crate::ArchiveBuilder for XBuilder {
        const NAME: &'static str = "X";
        const SCHEMA: &'static str = schema::x::X;

        fn new(
            storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
        ) -> Result<Self, crate::ResourceStorageError> {
            crate::create_archive::<Self>(&storage)?;
            Ok(Self { storage })
        }
    }
}

pub mod _builtin {

    pub mod multivector {

        pub mod schema {
            pub mod structs {
                pub const INDEX_TYPE32: &str = r#""#;
            }
        }
        #[derive(Clone, Debug)]
        pub struct IndexType32 {}

        #[derive(Clone, Copy)]
        pub struct IndexType32Ref<'a> {
            data: *const u8,
            _phantom: std::marker::PhantomData<&'a u8>,
        }

        impl<'a> crate::Struct<'a> for IndexType32 {
            const SCHEMA: &'static str = schema::structs::INDEX_TYPE32;
            const SIZE_IN_BYTES: usize = 4;
            const IS_OVERLAPPING_WITH_NEXT: bool = true;

            type Item = IndexType32Ref<'a>;

            #[inline]
            fn create(data: &'a [u8]) -> Self::Item {
                Self::Item {
                    data: data.as_ptr(),
                    _phantom: std::marker::PhantomData,
                }
            }

            type ItemMut = IndexType32Mut<'a>;

            #[inline]
            fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
                Self::ItemMut {
                    data: data.as_mut_ptr(),
                    _phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'a> IndexType32Ref<'a> {
            #[inline]
            pub fn value(&self) -> u64 {
                let value = flatdata_read_bytes!(u64, self.data, 0, 32);
                unsafe { std::mem::transmute::<u64, u64>(value) }
            }
            #[inline]
            pub fn range(&self) -> std::ops::Range<u64> {
                let start = flatdata_read_bytes!(u64, self.data, 0, 32);
                let end = flatdata_read_bytes!(u64, self.data, 0 + 4 * 8, 32);
                start..end
            }

            #[inline]
            pub fn as_ptr(&self) -> *const u8 {
                self.data
            }
        }

        impl<'a> std::fmt::Debug for IndexType32Ref<'a> {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.debug_struct("IndexType32")
                    .field("value", &self.value())
                    .finish()
            }
        }

        impl<'a> std::cmp::PartialEq for IndexType32Ref<'a> {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.value() == other.value()
            }
        }

        impl<'a> crate::Ref for IndexType32Ref<'a> {}

        pub struct IndexType32Mut<'a> {
            data: *mut u8,
            _phantom: std::marker::PhantomData<&'a u8>,
        }

        impl<'a> IndexType32Mut<'a> {
            #[inline]
            pub fn value(&self) -> u64 {
                let value = flatdata_read_bytes!(u64, self.data, 0, 32);
                unsafe { std::mem::transmute::<u64, u64>(value) }
            }

            #[inline]
            pub fn set_value(&mut self, value: u64) {
                let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 4) };
                flatdata_write_bytes!(u64; value, buffer, 0, 32)
            }

            #[inline]
            pub fn fill_from(&mut self, other: &IndexType32Ref) {
                self.set_value(other.value());
            }

            #[inline]
            pub fn as_ptr(&self) -> *const u8 {
                self.data
            }

            #[inline]
            pub fn as_mut_ptr(&self) -> *mut u8 {
                self.data
            }
        }

        impl<'a> std::fmt::Debug for IndexType32Mut<'a> {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                IndexType32Ref {
                    data: self.data,
                    _phantom: std::marker::PhantomData,
                }
                .fmt(f)
            }
        }

        impl<'a> crate::RefMut for IndexType32Mut<'a> {}

        impl<'a> crate::IndexStruct<'a> for IndexType32 {
            #[inline]
            fn range(data: Self::Item) -> std::ops::Range<usize> {
                let range = data.range();
                range.start as usize..range.end as usize
            }

            #[inline]
            fn set_index(mut data: Self::ItemMut, value: usize) {
                data.set_value(value as u64);
            }
        }
    }

    pub mod schema {
        pub mod structs {}
    }
}
